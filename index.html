<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>My Homepage</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #121212;
      --card: #1a1a1a;
      --muted: #aaa;
      --accent: #80cbc4;
      --btn: #333;
      --btn-hover: #444;
      --danger: #b55e5e; /*#ff4d4d;*/
      --card-width: 260px;
      --line-spacing: 6px;
      --font-size: 1rem;
    }
    html,body { height: 100%; margin: 0; background: var(--bg); color: #f0f0f0; font-family: system-ui, Arial, sans-serif; }
    .wrap { margin: 20px auto; padding: 0 18px; }

    /* header/manage */
    .manage-box { background: var(--card); padding: 14px; border-radius: 10px; margin-bottom: 18px; display: none; }
    .manage-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input[type="text"], input[type="url"], select {
      padding:8px 10px; border-radius:8px; border: none; outline: none; background:#141414; color:inherit;
      min-width: 200px;
    }
    /* new color input allowed without changing styling */
    input[type="color"] { padding:6px; height:36px; min-width:56px; }

    button { padding:8px 10px; border-radius:8px; border:none; background:var(--btn); color:#fff; cursor:pointer; }
    button:hover { background:var(--btn-hover); }
    #optionsBtn { position: fixed; top: 14px; right: 14px; width:42px; height:42px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:18px; background:transparent; border:none; color:var(--muted); cursor:pointer; }
    /*#optionsBtn.dirty { color: var(--danger); }*/
    /* A. background highlight (default) */ #optionsBtn.dirty { background: var(--danger);color: #fff; }

    #optionsBtn:hover { color: #fff; }

    /* New top bar to host site name + unified search centered */
    .topbar { display:flex; align-items:center; justify-content:center; gap:12px; margin-bottom:14px; }
    .brand-search { display:flex; align-items:center; gap:12px; }
    .site-title { font-size:1.6rem; font-weight:600; text-align:center; }
    .search-wrap { display:flex; align-items:center; gap:8px; background: #141414; padding:6px 8px; border-radius:10px; min-width:360px; max-width:760px; }
    .unified-input { background:transparent; border:0; color:inherit; outline:none; font-size:1rem; min-width:220px; }
    /* compact mode selector (replaces three adjacent buttons) */
    .mode-toggle { background:var(--bg); border-radius:8px; overflow:hidden; min-width:30px; font-size:1rem; text-align: center; }
    .mode-toggle { padding:0; }
    .mode-toggle.select { padding:0; }
    .mode-toggle:focus { outline: none; }
    .mode-toggle::-ms-expand { display: none; } /* hide IE arrow if needed */
    .search-action { padding:6px 8px; border-radius:8px; border:none; cursor:pointer; }

    h1 { display:none; } /* keep original h1 hidden since we now render dynamic site title */

    /* categories grid ‚Äî card width uses CSS var now */
    .categories { display:grid; gap:18px; grid-template-columns: repeat(auto-fit, minmax(var(--card-width), 1fr)); }
    .category { background: var(--card); border-radius:12px; padding:14px; box-shadow: 0 6px 14px rgba(0,0,0,0.4); overflow: visible; }
    .category-header { display:flex; align-items:center; gap:8px; border-bottom:1px solid rgba(255,255,255,0.03); padding-bottom:8px; margin-bottom:10px; position: relative; }
    .category-header h2 { margin:0; font-size:1.06rem; color:var(--accent); flex:1; }
    .header-buttons, .link-buttons { display:none; gap:6px; align-items:center; }

    /* EDIT MODE: do NOT show all header/link buttons globally.
       Instead, show them only for the hovered header / hovered link row,
       as a right-adjacent extension to that same row (no gap).
       Only the hovered row extends, not the entire card. */

    .category ul { list-style:none; padding:0; margin:0; }
    .category li { display:flex; gap:8px; align-items:center; margin:var(--line-spacing) 0; position: relative; }
    .category a { color: var(--accent); text-decoration:none; flex:1; word-break:break-word; font-size: var(--font-size); }
    .category a:hover { text-decoration: underline; }

    /* drag helpers */
    .drag-over { outline: 2px dashed rgba(128,203,196,0.9); border-radius:10px; }
    .drag-handle { cursor:grab; margin-right:6px; color:var(--muted); display:inline-flex; align-items:center; visibility: visible; }
    .drag-handle:active { cursor:grabbing; }

    /* commented visuals */
    .commented { text-decoration: line-through; opacity: 0.6; }

    /* small screens */
    @media (max-width:520px) {
      .manage-row { flex-direction:column; align-items:stretch; }
      input[type="text"], input[type="url"], select, input[type="color"] { min-width: 100%; }
      .search-wrap { min-width: auto; width: 100%; }
      .topbar { padding: 0 8px; }
    }

    /* --------------------
       Adjacent-extension behavior for edit-mode:
       - Controls are hidden by default in edit mode
       - When hovering a specific .category-header or .category li we display
         the associated controls as a right extension directly adjacent to the hovered row.
       - The extension is a child of the hovered row (so moving the mouse into it doesn't lose hover)
       - The extension may overlap the next card (it won't push layout).
       -------------------- */

    /* Hide controls by default in edit mode (do not remove capability) */
    body.edit-mode .header-buttons,
    body.edit-mode .link-buttons,
    body.edit-mode .drag-handle {
      visibility: hidden;
      display: none;
    }

    /* Adjacent extension: no gap (left:100% and margin-left:0).
       Because the buttons are children of the hovered row and absolutely positioned,
       moving the mouse directly into the extension will keep the row hovered. */
    body.edit-mode .category-header:hover .header-buttons,
    body.edit-mode .category li:hover .link-buttons {
      display: flex;
      visibility: visible;
      position: absolute;
      /* Changed: center vertically relative to the hovered row to fix slight vertical misalignment */
      top: 50%;
      left: 100%;
      margin-left: 0; /* adjacent: no gap */
      z-index: 40;
      background: var(--card);
      padding: 8px;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.55);
      align-items: center;
      gap: 8px;
      white-space: nowrap;
      min-height: 36px;
      /* small negative translate to slightly overlap the border and ensure no micro-gap
         Updated: translate both horizontally and vertically to maintain previous horizontal overlap
         while vertically centering (-50%). */
      transform: translate(-60px, -50%);
    }

    /* Show drag handle inline inside the adjacent extension on hover */
    body.edit-mode .category-header:hover .drag-handle,
    body.edit-mode .category li:hover .drag-handle {
      visibility: visible;
      display: inline-flex;
    }

    /* Bring hovered row to front so its extension can overlap neighbors */
    body.edit-mode .category-header:hover,
    body.edit-mode .category li:hover {
      z-index: 30;
    }

    /* Ensure cards do not clip the extension */
    .categories, .category { overflow: visible; }
  </style>
</head>
<body>
  <button id="optionsBtn" title="Toggle edit mode">‚öôÔ∏è</button>

  <div class="wrap">
    <!-- Manage box (top) -->
    <div class="manage-box" id="manageBox" aria-hidden="true">
      <h2 style="margin-top:0">Manage Categories & Links</h2>

      <!-- NEW: site name input in manage box (global prop) -->
      <div style="margin-bottom:10px;" class="manage-row">
        <label style="display:flex;align-items:center;gap:8px;">
          Site name:
          <input type="text" id="propSiteName" placeholder="Site name (leave blank to hide)" />
        </label>
      </div>

      <div class="manage-row">
        <form id="addCategoryForm" style="display:flex; gap:8px; align-items:center;">
          <input type="text" id="newCategory" placeholder="New Category" required />
          <button type="submit">Add Category</button>
        </form>

        <form id="addLinkForm" style="display:flex; gap:8px; align-items:center;">
          <select id="categorySelect" title="Choose category"></select>
          <input type="text" id="linkName" placeholder="Link Name" required />
          <input type="url" id="linkUrl" placeholder="https://example.com" required />
          <button type="submit">Add Link</button>
        </form>

        <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
          <button id="exportGithubBtn" title="Copy and open GitHub edit page">Export to GitHub</button>
          <button id="exportBtn" title="Export current settings to INI and reset to baseline">Export & Reset</button>
          <button id="resetLocalBtn" title="Discard local edits and reload baseline">Discard Local</button>
        </div>
      </div>

      <!-- NEW: General view properties (minimal, non-destructive addition) -->
      <h3 style="margin-bottom:6px; margin-top:12px">General View Properties</h3>
      <div class="manage-row" style="align-items:center;">
        <label style="display:inline-flex; align-items:center; gap:8px;">
          Link color:
          <input type="color" id="propLinkColor" title="Link color" />
        </label>

        <label style="display:inline-flex; align-items:center; gap:8px;">
          Card width (regular):
          <input type="text" id="propCardWidth" placeholder="260px" title="Example: 260px or 20rem" />
        </label>

        <!-- NEW: separate edit-mode card width -->
        <label style="display:inline-flex; align-items:center; gap:8px;">
          Card width (edit mode):
          <input type="text" id="propCardWidthEdit" placeholder="300px" title="Card width when in edit mode" />
        </label>

        <label style="display:inline-flex; align-items:center; gap:8px;">
          Line spacing:
          <input type="text" id="propLineSpacing" placeholder="6px" title="Vertical margin between links, e.g. 6px" />
        </label>

        <label style="display:inline-flex; align-items:center; gap:8px;">
          Font size:
          <input type="text" id="propFontSize" placeholder="1rem" title="Link font size, e.g. 1rem or 14px" />
        </label>
      </div>
    </div>

    <!-- TOP BAR: site title + unified search + compact mode selector (dropdown); gear remains fixed at top-right -->
    <div class="topbar" role="banner">
      <div class="brand-search">
        <div id="siteTitle" class="site-title"></div>
        <div class="search-wrap" role="search" aria-label="Unified search / task input">
          <!-- Changed: compact dropdown select replaces the three adjacent buttons -->
          <select id="modeToggle" class="mode-toggle" title="Mode: Filter / Google / ChatGPT">
            <option value="filter">Filter</option>
            <option value="google">Google</option>
            <option value="chatgpt">ChatGPT</option>
          </select>
          <input id="unifiedInput" class="unified-input" placeholder="Search" autocomplete="off" autofocus/>
          <button id="searchAction" class="search-action" title="Run action">Go</button>
        </div>
      </div>
    </div>

    <h1>My Homepage</h1>

    <div class="categories" id="categories" aria-live="polite"></div>
  </div>

  <script>
    // -------------------------
    // CONFIG
    const BASE_FILENAME = 'data.txt'; // must be in same dir as index.html
    const COMMENT_PREFIX = '#';
    // -------------------------

    // app state (keeps the original array structure for categories)
    let baseData = [];       // baseline categories (array) ‚Äî original structure preserved
    let data = [];           // working categories (array) ‚Äî original structure preserved

    // new: view props (category-less lines at top of data.txt)
    let baseProps = {};      // baseline props from file
    let viewProps = {};      // current (editable) props in memory

    let isEditMode = false;

    // DOM
    const categoriesDiv = document.getElementById('categories');
    const categorySelect = document.getElementById('categorySelect');
    const manageBox = document.getElementById('manageBox');
    const optionsBtn = document.getElementById('optionsBtn');
    const exportGithubBtn = document.getElementById('exportGithubBtn');
    const exportBtn = document.getElementById('exportBtn');
    const resetLocalBtn = document.getElementById('resetLocalBtn');
    const siteTitleEl = document.getElementById('siteTitle');
    const unifiedInput = document.getElementById('unifiedInput');
    const modeToggle = document.getElementById('modeToggle'); // now the select
    const searchAction = document.getElementById('searchAction');

    // default view props (used when baseline doesn't include them)
    const defaultProps = {
      linkColor: '#80cbc4',
      cardWidth: '260px',
      // NEW: edit-mode card width default equals regular by default
      cardWidthEdit: '260px',
      lineSpacing: '6px',
      fontSize: '1rem',
      siteName: 'My Homepage'
    };

    // -------------------------
    // UTIL: parse INI-style (with # comments)
    // Extended to parse category-less "props" lines at the start:
    // key = value
    function parseINI(text) {
      const lines = text.split(/\r?\n/);
      const cats = [];
      const props = {};
      let current = null;
      for (let rawLine of lines) {
        if (!rawLine) continue;
        // preserve leading/trailing spaces only for comment detection
        const trimmed = rawLine.trim();
        if (!trimmed) continue;

        // Commented line
        if (trimmed.startsWith(COMMENT_PREFIX)) {
          const uncomment = trimmed.slice(1).trim();
          if (!uncomment) continue;

          // commented category header
          if (uncomment.startsWith('[') && uncomment.endsWith(']')) {
            const name = uncomment.slice(1, -1).trim();
            current = { name, links: [], commented: true };
            cats.push(current);
            continue;
          }

          // commented link line (name = url)
          const idx2 = uncomment.indexOf('=');
          if (idx2 >= 0 && current) {
            const name = uncomment.slice(0, idx2).trim();
            const url = uncomment.slice(idx2 + 1).trim();
            if (name) current.links.push({ name, url, commented: true });
          }
          // other comment lines are ignored for structure
          continue;
        }

        // Non-commented category header
        if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
          const name = trimmed.slice(1, -1).trim();
          current = { name, links: [], commented: false };
          cats.push(current);
          continue;
        }

        // Non-commented key=value
        const idx = trimmed.indexOf('=');
        if (idx >= 0) {
          const left = trimmed.slice(0, idx).trim();
          const right = trimmed.slice(idx + 1).trim();
          if (!current) {
            // before first category: treat as a (page) prop
            props[left] = right;
          } else {
            // a regular link line
            const name = left;
            const url = right;
            if (name) current.links.push({ name, url, commented: false });
          }
        }
      }
      return { props, cats };
    }

    // toINI: write props at top (category-less) then categories
    function toINI(propsObj, catsArr) {
      const lines = [];
      // props first
      for (const key of Object.keys(propsObj || {})) {
        lines.push(`${key} = ${propsObj[key]}`);
      }
      if (lines.length) lines.push(''); // blank separator

      // categories and links (preserve commented flags)
      for (const cat of catsArr) {
        if (cat.commented) lines.push(`# [${cat.name}]`);
        else lines.push(`[${cat.name}]`);
        for (const l of cat.links) {
          if (l.commented) lines.push(`# ${l.name} = ${l.url}`);
          else lines.push(`${l.name} = ${l.url}`);
        }
        lines.push(''); // blank line between categories
      }

      // remove trailing blank line
      while (lines.length && lines[lines.length - 1].trim() === '') lines.pop();
      return lines.join('\n');
    }

    function deepEqual(a, b) {
      if (a === b) return true;
      try {
        return JSON.stringify(a) === JSON.stringify(b);
      } catch (e) {
        return false;
      }
    }

    function clone(obj) { return JSON.parse(JSON.stringify(obj)); }

    function updateDirtyFlag() {
      const dirty = !deepEqual(data, baseData) || !deepEqual(viewProps, baseProps);
      if (dirty) optionsBtn.classList.add('dirty');
      else optionsBtn.classList.remove('dirty');
    }

    function persistLocal() {
      // store both categories and props
      localStorage.setItem('homepageData', JSON.stringify({ props: viewProps, cats: data }));
      updateDirtyFlag();
    }

    function clearLocalAndReloadBaseline() {
      localStorage.removeItem('homepageData');
      loadBaseline().catch(err => {
        console.error('Failed reload baseline:', err);
      });
    }

    function applyProps(p) {
      const props = Object.assign({}, defaultProps, p || {});
      // Use regular card width ALWAYS ‚Äî even in edit mode ignore cardWidthEdit for sizing.
      // This implements: "render the card width in edit mode exactly as it would in the regular mode"
      const cardWidthToUse = (props.cardWidth || defaultProps.cardWidth);

      document.documentElement.style.setProperty('--accent', props.linkColor);
      document.documentElement.style.setProperty('--card-width', cardWidthToUse);
      document.documentElement.style.setProperty('--line-spacing', props.lineSpacing);
      document.documentElement.style.setProperty('--font-size', props.fontSize);

      // site title handling: hide if blank in regular view
      const s = props.siteName || '';
      siteTitleEl.textContent = s;
      // if empty, hide entirely in regular view
      if (!s) siteTitleEl.style.display = isEditMode ? 'block' : 'none';
      else siteTitleEl.style.display = 'block';

      // also set document title for clarity
      document.title = s || 'My Homepage';
    }

    async function loadBaseline() {
      try {
        const res = await fetch(BASE_FILENAME, { cache: 'no-cache' });
        if (!res.ok) throw new Error('Failed to fetch baseline file');
        const txt = await res.text();

        const parsed = parseINI(txt);
        baseProps = parsed.props || {};
        baseData = parsed.cats || [];

        const local = localStorage.getItem('homepageData');
        if (local) {
          try {
            const parsedLocal = JSON.parse(local);
            // support new shape { props, cats } or old shape (array) for backward compatibility
            if (parsedLocal && Array.isArray(parsedLocal.cats)) {
              data = parsedLocal.cats;
              viewProps = Object.assign({}, defaultProps, parsedLocal.props || baseProps);
            } else if (Array.isArray(parsedLocal)) {
              // old format: array of categories only
              data = parsedLocal;
              viewProps = Object.assign({}, defaultProps, baseProps);
            } else {
              data = clone(baseData);
              viewProps = Object.assign({}, defaultProps, baseProps);
            }
          } catch (e) {
            data = clone(baseData);
            viewProps = Object.assign({}, defaultProps, baseProps);
          }
        } else {
          data = clone(baseData);
          viewProps = Object.assign({}, defaultProps, baseProps);
        }

        // ensure baseProps has defaults for missing keys
        baseProps = Object.assign({}, defaultProps, baseProps);

        applyProps(viewProps);
        updateDirtyFlag();
        render();
        syncPropInputs();
      } catch (err) {
        console.error(err);
        const local = localStorage.getItem('homepageData');
        if (local) {
          try {
            const parsedLocal = JSON.parse(local);
            if (parsedLocal && Array.isArray(parsedLocal.cats)) {
              data = parsedLocal.cats;
              viewProps = Object.assign({}, defaultProps, parsedLocal.props || {});
            } else if (Array.isArray(parsedLocal)) {
              data = parsedLocal;
              viewProps = Object.assign({}, defaultProps);
            } else {
              data = [];
              viewProps = Object.assign({}, defaultProps);
            }
          } catch {
            data = [];
            viewProps = Object.assign({}, defaultProps);
          }
        } else {
          data = [];
          viewProps = Object.assign({}, defaultProps);
        }
        baseData = clone(data);
        baseProps = Object.assign({}, viewProps);
        applyProps(viewProps);
        updateDirtyFlag();
        render();
        syncPropInputs();
      }
    }

    // -------------------------
    // RENDER / UI
    function syncPropInputs() {
      document.getElementById('propLinkColor').value = viewProps.linkColor || defaultProps.linkColor;
      document.getElementById('propCardWidth').value = viewProps.cardWidth || defaultProps.cardWidth;
      // NEW: sync edit-mode card width input
      document.getElementById('propCardWidthEdit').value = viewProps.cardWidthEdit || defaultProps.cardWidthEdit;
      document.getElementById('propLineSpacing').value = viewProps.lineSpacing || defaultProps.lineSpacing;
      document.getElementById('propFontSize').value = viewProps.fontSize || defaultProps.fontSize;
      document.getElementById('propSiteName').value = viewProps.siteName || defaultProps.siteName;
    }

    function render() {
      categoriesDiv.innerHTML = '';
      if (categorySelect) categorySelect.innerHTML = '';

      // apply view props every render (keeps UI in sync)
      applyProps(viewProps);

      data.forEach((cat, ci) => {
        // In regular (non-edit) mode, hide commented categories completely
        if (!isEditMode && cat.commented) return;

        const opt = document.createElement('option');
        opt.value = ci;
        opt.textContent = cat.name;
        categorySelect.appendChild(opt);

        const card = document.createElement('div');
        card.className = 'category';
        card.dataset.catIndex = ci;

        const header = document.createElement('div');
        header.className = 'category-header';

        const h2 = document.createElement('h2');
        h2.textContent = cat.name;
        if (isEditMode && cat.commented) {
          h2.classList.add('commented');
        }
        header.appendChild(h2);

        const hdrBtns = document.createElement('div');
        hdrBtns.className = 'header-buttons';


        const handle = document.createElement('span');
        handle.className = 'drag-handle';
        handle.textContent = '‚â°';
        if (!isEditMode) handle.style.visibility = 'hidden';
        handle.addEventListener('dragstart', (e) => {
          dragSrc = { type: 'category', index: ci };
          e.dataTransfer.effectAllowed = 'move';
        });
        handle.draggable = isEditMode;
        hdrBtns.appendChild(handle);


        const editCatBtn = document.createElement('button');
        editCatBtn.textContent = '‚úèÔ∏è';
        editCatBtn.title = 'Rename category';
        editCatBtn.addEventListener('click', () => {
          const n = prompt('Rename category:', cat.name);
          if (!n) return;
          cat.name = n.trim();
          if (!cat.name) { alert('Name cannot be empty'); return; }
          let duplicate = data.some((c, idx) => idx !== ci && c.name === cat.name);
          if (duplicate) {
            alert('Another category with that name exists.');
            return;
          }
          persistLocal();
          render();
        });
        hdrBtns.appendChild(editCatBtn);

        const delCatBtn = document.createElement('button');
        delCatBtn.textContent = 'üóëÔ∏è';
        delCatBtn.title = 'Delete category';
        delCatBtn.addEventListener('click', () => {
          if (!confirm(`Delete category "${cat.name}" and all its links?`)) return;
          data.splice(ci, 1);
          persistLocal();
          render();
        });
        hdrBtns.appendChild(delCatBtn);

        // Checkbox: checked = visible (not commented). unchecked = commented
        const catCheckbox = document.createElement('input');
        catCheckbox.type = 'checkbox';
        catCheckbox.title = 'Checked = visible. Unchecked = commented/hidden.';
        catCheckbox.checked = !Boolean(cat.commented);
        catCheckbox.addEventListener('change', () => {
          cat.commented = !catCheckbox.checked;
          persistLocal();
          render();
        });
        hdrBtns.appendChild(catCheckbox);


        const addCatBtn = document.createElement('button');
        addCatBtn.textContent = '+';
        addCatBtn.title = 'Add new category after this';
        addCatBtn.addEventListener('click', () => {
          let cname = prompt('Category name:', 'New Category');
          if (!cname) return;
          cname = cname.trim();
          if (!cname) return;
          const newCat = { name: cname, links: [{ name: 'New Link', url: '', commented: false }], commented: false };
          data.splice(ci+1, 0, newCat);
          persistLocal();
          render();
        });
        hdrBtns.appendChild(addCatBtn);





        header.appendChild(hdrBtns);
        card.appendChild(header);

        const ul = document.createElement('ul');
        cat.links.forEach((link, li) => {
          // In regular mode, hide commented links
          if (!isEditMode && link.commented) return;

          const liEl = document.createElement('li');
          liEl.dataset.catIndex = ci;
          liEl.dataset.linkIndex = li;

          const a = document.createElement('a');
          a.href = link.url;
          a.textContent = link.name;
          a.target = '_self'; // same tab
          // a.target = '_blank'; // new tab
          if (isEditMode && link.commented) {
            a.classList.add('commented');
          }
          liEl.appendChild(a);

          const linkBtns = document.createElement('div');
          linkBtns.className = 'link-buttons';

          const linkHandle = document.createElement('span');
          linkHandle.className = 'drag-handle';
          linkHandle.textContent = '‚â°';
          if (!isEditMode) linkHandle.style.visibility = 'hidden';
          linkHandle.addEventListener('dragstart', (e) => {
            dragSrc = { type: 'link', cat: ci, index: li };
            e.dataTransfer.effectAllowed = 'move';
          });
          linkHandle.draggable = isEditMode;
          linkBtns.appendChild(linkHandle);

          const editL = document.createElement('button');
          editL.textContent = '‚úèÔ∏è';
          editL.title = 'Edit link';
          editL.addEventListener('click', () => {
            const nn = prompt('Link name:', link.name);
            const uu = prompt('Link URL:', link.url);
            if (!nn || !uu) return;
            data[ci].links[li] = { name: nn.trim(), url: uu.trim(), commented: Boolean(link.commented) };
            persistLocal();
            render();
          });
          linkBtns.appendChild(editL);

          const delL = document.createElement('button');
          delL.textContent = '‚ùå';
          delL.title = 'Delete link';
          delL.addEventListener('click', () => {
            data[ci].links.splice(li, 1);
            // if (data[ci].links.length === 0) {
            //   data.splice(ci, 1);
            // }
            persistLocal();
            render();
          });
          linkBtns.appendChild(delL);

          // Checkbox for link: checked = visible (not commented)
          const linkCheckbox = document.createElement('input');
          linkCheckbox.type = 'checkbox';
          linkCheckbox.title = 'Checked = visible. Unchecked = commented/hidden.';
          linkCheckbox.checked = !Boolean(link.commented);
          linkCheckbox.addEventListener('change', () => {
            link.commented = !linkCheckbox.checked;
            persistLocal();
            render();
          });
          linkBtns.appendChild(linkCheckbox);

          const addLinkBtn = document.createElement('button');
          addLinkBtn.textContent = '+';
          addLinkBtn.title = 'Add new link below this';
          addLinkBtn.addEventListener('click', () => {
            const nn = prompt('Link name:', 'New Link');
            if (!nn) return;
            const uu = prompt('Link URL:', '');
            if (uu === null) return;
            const newLink = { name: nn.trim(), url: uu.trim(), commented: false };
            data[ci].links.splice(li+1, 0, newLink);
            persistLocal();
            render();
          });
          linkBtns.appendChild(addLinkBtn);




          liEl.appendChild(linkBtns);
          ul.appendChild(liEl);
        });

        card.appendChild(ul);
        categoriesDiv.appendChild(card);
      });

      setupDragAndDrop();
      updateDirtyFlag();
    }

    // -------------------------
    // DRAG & DROP
    let dragSrc = null;

    function setupDragAndDrop() {
      if (!isEditMode) return;

      document.querySelectorAll('.category').forEach(catEl => {
        catEl.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (dragSrc) catEl.classList.add('drag-over');
        });

        catEl.addEventListener('dragleave', () => catEl.classList.remove('drag-over'));

        catEl.addEventListener('drop', (e) => {
          e.preventDefault();
          catEl.classList.remove('drag-over');
          if (!dragSrc) return;
          const targetCatIndex = +catEl.dataset.catIndex;

          if (dragSrc.type === 'category') {
            const from = dragSrc.index, to = targetCatIndex;
            if (from !== to) {
              const moved = data.splice(from, 1)[0];
              const adjTo = (from < to) ? to - 1 : to;
              data.splice(adjTo, 0, moved);
              persistLocal();
              render();
            }
          } else if (dragSrc.type === 'link') {
            const { cat: fromCat, index: fromLink } = dragSrc;
            const moved = data[fromCat].links.splice(fromLink, 1)[0];
            data[targetCatIndex].links.push(moved);
            // if (data[fromCat] && data[fromCat].links.length === 0) {
            //   data.splice(fromCat, 1);
            // }
            persistLocal();
            render();
          }
          dragSrc = null;
        });
      });

      document.querySelectorAll('.category li').forEach(liEl => {
        liEl.addEventListener('dragover', (e) => {
          if (!dragSrc || dragSrc.type !== 'link') return;
          e.preventDefault();
          e.stopPropagation();
          liEl.classList.add('drag-over');
        });

        liEl.addEventListener('dragleave', () => liEl.classList.remove('drag-over'));

        liEl.addEventListener('drop', (e) => {
          if (!dragSrc || dragSrc.type !== 'link') return;
          e.preventDefault();
          e.stopPropagation();
          liEl.classList.remove('drag-over');

          const fromCat = dragSrc.cat;
          const fromIdx = dragSrc.index;
          const toCat = +liEl.dataset.catIndex;
          let toIdx = +liEl.dataset.linkIndex;

          const moved = data[fromCat].links.splice(fromIdx, 1)[0];

          if (fromCat === toCat) {
            if (fromIdx < toIdx) toIdx--;
            data[toCat].links.splice(toIdx, 0, moved);
          } else {
            data[toCat].links.splice(toIdx, 0, moved);
            // if (data[fromCat].links.length === 0) {
            //   data.splice(fromCat, 1);
            // }
          }

          persistLocal();
          render();
          dragSrc = null;
        });
      });
    }

    // -------------------------
    // EVENT HANDLERS
    document.getElementById('addCategoryForm').addEventListener('submit', e => {
      e.preventDefault();
      const input = document.getElementById('newCategory');
      const name = input.value.trim();
      if (!name) return;
      if (data.some(c => c.name === name)) {
        alert('Category already exists.');
        return;
      }
      // default commented: false
      data.push({ name, links: [], commented: false });
      input.value = '';
      persistLocal();
      render();
    });

    document.getElementById('addLinkForm').addEventListener('submit', e => {
      e.preventDefault();
      const ci = +categorySelect.value;
      const name = document.getElementById('linkName').value.trim();
      const url = document.getElementById('linkUrl').value.trim();
      if (!name || !url) return;
      // default commented: false
      data[ci].links.push({ name, url, commented: false });
      document.getElementById('linkName').value = '';
      document.getElementById('linkUrl').value = '';
      persistLocal();
      render();
    });

    optionsBtn.addEventListener('click', () => {
      isEditMode = !isEditMode;
      document.body.classList.toggle('edit-mode', isEditMode);
      manageBox.style.display = isEditMode ? 'block' : 'none';
      // sync inputs when entering edit mode
      if (isEditMode) syncPropInputs();
      render();
    });

    exportGithubBtn.addEventListener("click", () => {
      const ini = toINI(viewProps, data);
      navigator.clipboard.writeText(ini).then(() => {
        alert("Data copied to clipboard. A new tab will open ‚Äî paste it into GitHub and commit.");

        // preserve original behavior: clear local and open the edit URL
        clearLocalAndReloadBaseline();
        const editUrl = `https://github.com/haimheled/haimheled.github.io/edit/master/data.txt`;
        // Open in SAME window
        window.location.href = editUrl;
      }).catch(err => {
        console.error("Clipboard copy failed", err);
        alert("Failed to copy to clipboard. You can copy manually.");
      });
    });

    exportBtn.addEventListener('click', () => {
      const blob = new Blob([toINI(viewProps, data)], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = BASE_FILENAME;
      a.click();
      clearLocalAndReloadBaseline();
    });

    resetLocalBtn.addEventListener('click', () => {
      if (!confirm('Discard local edits and reload baseline?')) return;
      clearLocalAndReloadBaseline();
    });

    // -------------------------
    // Unified search/task field logic
    // Modes: filter (live), google, chatgpt
    let currentMode = 'filter'; // default on page load

    // mode select (dropdown) change handling (replaces previous button clicks)
    if (modeToggle) {
      modeToggle.value = currentMode;
      modeToggle.addEventListener('change', () => {
        currentMode = modeToggle.value;
        // if switched to filter, run immediate filtering on current input
        if (currentMode === 'filter') runFilter(unifiedInput.value || '');
      });
    }

    // live input handler: only active in filter mode
    unifiedInput.addEventListener('input', (e) => {
      if (currentMode === 'filter') runFilter(e.target.value);
    });

    // action button for google/chatgpt modes (and also performs filter when mode=filter)
    searchAction.addEventListener('click', () => {
      const q = (unifiedInput.value || '').trim();
      if (currentMode === 'filter') {
        runFilter(q);
        return;
      }
      if (!q) return;
      if (currentMode === 'google') {
        const url = `https://www.google.com/search?q=${encodeURIComponent(q)}`;
        window.open(url, '_blank');
      } else if (currentMode === 'chatgpt') {
        // open ChatGPT (or a placeholder) in new tab with query param
        const url = `https://chat.openai.com/?q=${encodeURIComponent(q)}`;
        window.open(url, '_blank');
      }
    });

    // also support pressing Enter: if filter mode ‚Äî keep live; else trigger action
    unifiedInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (currentMode === 'filter') {
          runFilter(unifiedInput.value || '');
        } else {
          searchAction.click();
        }
      }
    });

    function runFilter(q) {
      const ql = (q || '').trim().toLowerCase();
      document.querySelectorAll('.category').forEach(catEl => {
        let showCat = false;
        catEl.querySelectorAll('li').forEach(liEl => {
          const a = liEl.querySelector('a');
          const match = a.textContent.toLowerCase().includes(ql);
          liEl.style.display = match ? '' : 'none';
          if (match) showCat = true;
        });
        catEl.style.display = showCat ? '' : 'none';
      });
    }

    // legacy filter input removed (behaviour replaced by unifiedInput)

    function redirectChatGPT(form) {
      const q = form.q.value.trim();
      if (!q) return;
      form.action = `https://chatgpt.com/?q=${encodeURIComponent(q)}`;
    }

    // -------------------------
    // Sync view props inputs -> state
    function updateViewPropsFromInputs() {
      const lc = document.getElementById('propLinkColor').value || defaultProps.linkColor;
      const cw = document.getElementById('propCardWidth').value || defaultProps.cardWidth;
      const cwe = document.getElementById('propCardWidthEdit').value || defaultProps.cardWidthEdit;
      const ls = document.getElementById('propLineSpacing').value || defaultProps.lineSpacing;
      const fs = document.getElementById('propFontSize').value || defaultProps.fontSize;
      const sn = document.getElementById('propSiteName').value || defaultProps.siteName;

      viewProps.linkColor = lc;
      viewProps.cardWidth = cw;
      // NEW: store edit-mode card width separately (but it's not used for sizing in edit mode)
      viewProps.cardWidthEdit = cwe;
      viewProps.lineSpacing = ls;
      viewProps.fontSize = fs;
      viewProps.siteName = sn;

      // immediately apply and persist
      applyProps(viewProps);
      persistLocal();
      render();
    }

    // attach listeners to prop inputs
    ['propLinkColor','propCardWidth','propCardWidthEdit','propLineSpacing','propFontSize','propSiteName'].forEach(id=>{
      const el = document.getElementById(id);
      el.addEventListener('input', updateViewPropsFromInputs);
      // also listen to 'change' for color pickers in some browsers
      el.addEventListener('change', updateViewPropsFromInputs);
    });

    // -------------------------
    // INIT
    loadBaseline();
  </script>
</body>
</html>
